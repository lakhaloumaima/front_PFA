{"ast":null,"code":"var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n\n};\n\nconst now = () => new Date().getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n\n  recordPing() {\n    this.pingedAt = now();\n  }\n\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale();\n      this.poll();\n    }, this.getPollInterval());\n  }\n\n  getPollInterval() {\n    const {\n      staleThreshold: staleThreshold,\n      reconnectionBackoffRate: reconnectionBackoffRate\n    } = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }, 200);\n    }\n  }\n\n}\n\nConnectionMonitor.staleThreshold = 6;\nConnectionMonitor.reconnectionBackoffRate = .15;\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n};\nconst {\n  message_types: message_types,\n  protocols: protocols\n} = INTERNAL;\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [...protocols, ...(this.consumer.subprotocols || [])];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n\n  close({\n    allowReconnect: allowReconnect\n  } = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n\n  isOpen() {\n    return this.isState(\"open\");\n  }\n\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n\n    return null;\n  }\n\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function () {};\n    }\n  }\n\n}\n\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n\n    const {\n      identifier: identifier,\n      message: message,\n      reason: reason,\n      reconnect: reconnect,\n      type: type\n    } = JSON.parse(event.data);\n\n    switch (type) {\n      case message_types.welcome:\n        if (this.triedToReconnect()) {\n          this.reconnectAttempted = true;\n        }\n\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`);\n        return this.close({\n          allowReconnect: reconnect\n        });\n\n      case message_types.ping:\n        return this.monitor.recordPing();\n\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n\n        if (this.reconnectAttempted) {\n          this.reconnectAttempted = false;\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: true\n          });\n        } else {\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: false\n          });\n        }\n\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n\n    if (this.disconnected) {\n      return;\n    }\n\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n\n};\n\nconst extend = function (object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n\n    this.startGuaranteeing();\n  }\n\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);\n  }\n\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map(subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        });\n      }\n    }, 500);\n  }\n\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n\n  remove(subscription) {\n    this.forget(subscription);\n\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n\n    return subscription;\n  }\n\n  reject(identifier) {\n    return this.findAll(identifier).map(subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    });\n  }\n\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter(s => s !== subscription);\n    return subscription;\n  }\n\n  findAll(identifier) {\n    return this.subscriptions.filter(s => s.identifier === identifier);\n  }\n\n  reload() {\n    return this.subscriptions.map(subscription => this.subscribe(subscription));\n  }\n\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));\n  }\n\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [subscription];\n    }\n\n    return subscriptions.map(subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined);\n  }\n\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));\n  }\n\n  sendCommand(subscription, command) {\n    const {\n      identifier: identifier\n    } = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n\n  send(data) {\n    return this.connection.send(data);\n  }\n\n  connect() {\n    return this.connection.open();\n  }\n\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [...this.subprotocols, subprotocol];\n  }\n\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };","map":{"version":3,"names":["adapters","logger","console","undefined","WebSocket","log","messages","enabled","push","Date","now","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","backoff","Math","pow","min","jitterMax","jitter","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","remote","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reconnectAttempted","reload","confirmSubscription","notify","reconnected","reject","notifyAll","willAttemptReconnect","extend","object","properties","key","value","Subscription","params","mixin","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","Consumer","_url","createWebSocketURL","connect","addSubProtocol","subprotocol","test","a","createElement","href","replace","createConsumer","getConfig","name","element","head","querySelector","getAttribute"],"sources":["/home/oumaima/Documents/MON_PFA/front/node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js"],"sourcesContent":["var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordPing() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [ ...protocols, ...this.consumer.subprotocols || [] ];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    switch (type) {\n     case message_types.welcome:\n      if (this.triedToReconnect()) {\n        this.reconnectAttempted = true;\n      }\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return this.monitor.recordPing();\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      if (this.reconnectAttempted) {\n        this.reconnectAttempted = false;\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: true\n        });\n      } else {\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: false\n        });\n      }\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [ ...this.subprotocols, subprotocol ];\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}