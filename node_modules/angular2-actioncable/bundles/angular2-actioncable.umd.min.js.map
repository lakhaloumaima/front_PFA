{"version":3,"file":"angular2-actioncable.umd.min.js","sources":["../../../node_modules/tslib/tslib.es6.js","../../../node_modules/rxjs/src/internal/util/isFunction.ts","../../../node_modules/rxjs/src/internal/config.ts","../../../node_modules/rxjs/src/internal/util/hostReportError.ts","../../../node_modules/rxjs/src/internal/Observer.ts","../../../node_modules/rxjs/src/internal/util/isObject.ts","../../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../../node_modules/rxjs/src/internal/Subscription.ts","../../../node_modules/rxjs/src/internal/symbol/rxSubscriber.ts","../../../node_modules/rxjs/src/internal/Subscriber.ts","../../../node_modules/rxjs/src/internal/Observable.ts","../../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../../node_modules/rxjs/src/internal/util/pipe.ts","../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../node_modules/rxjs/src/internal/Subject.ts","../../../node_modules/rxjs/src/internal/operators/refCount.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../../../node_modules/rxjs/src/internal/scheduler/Action.ts","../../../node_modules/rxjs/src/internal/Scheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../../../node_modules/rxjs/src/internal/util/Immediate.ts","../../../node_modules/rxjs/src/internal/scheduler/async.ts","../../../node_modules/rxjs/src/internal/util/EmptyError.ts","../../../node_modules/rxjs/src/internal/operators/debounceTime.ts","../../../node_modules/rxjs/src/internal/operators/windowToggle.ts","~/angular2-actioncable/src/cable.ts","~/angular2-actioncable/src/action-cable.service.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","export const rxSubscriber =\n  (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? Symbol.for('rxSubscriber')\n    : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver, TeardownLogic } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  private _parentSubscription: Subscription | null = null;\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): For situations where Node has multiple copies of rxjs in\n          // node_modules, we cannot rely on `instanceof` checks\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber._addParentTeardownLogic(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n      this._unsubscribeParentSubscription();\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n      this._unsubscribeParentSubscription();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _addParentTeardownLogic(parentTeardownLogic: TeardownLogic) {\n    if (parentTeardownLogic !== this) {\n      this._parentSubscription = this.add(parentTeardownLogic);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeParentSubscription() {\n    if (this._parentSubscription !== null) {\n      this._parentSubscription.unsubscribe();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    this._parentSubscription = null;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('_addParentTeardownLogic' in obj && obj[rxSubscriberSymbol]);\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink._addParentTeardownLogic(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nfunction ObjectUnsubscribedErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'object unsubscribed';\n  this.name = 'ObjectUnsubscribedError';\n  return this;\n}\n\nObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    clearInterval(id);\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport class Scheduler implements SchedulerLike {\n\n  /**\n   * Note: the extra arrow function wrapper is to make testing by overriding\n   * Date.now easier.\n   * @nocollapse\n   */\n  public static now: () => number = () => Date.now();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","let nextHandle = 1;\n\nconst tasksByHandle: { [handle: string]: () => void } = {};\n\nfunction runIfPresent(handle: number) {\n  const cb = tasksByHandle[handle];\n  if (cb) {\n    cb();\n  }\n}\n\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    tasksByHandle[handle] = cb;\n    Promise.resolve().then(() => runIfPresent(handle));\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    delete tasksByHandle[handle];\n  },\n};\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```javascript\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```javascript\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","export interface EmptyError extends Error {\n}\n\nexport interface EmptyErrorCtor {\n  new(): EmptyError;\n}\n\nfunction EmptyErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'no elements in sequence';\n  this.name = 'EmptyError';\n  return this;\n}\n\nEmptyErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = EmptyErrorImpl as any;","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      const { lastValue } = this;\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively when scheduled with things like\n      // VirtualScheduler/TestScheduler.\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : empty()),\n *   mergeAll(),\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings as any));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n\n      const { closingSelector } = this;\n      const closingNotifier = tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject) {\n        return this.error(errorObject.e);\n      } else {\n        const window = new Subject<T>();\n        const subscription = new Subscription();\n        const context = { window, subscription };\n        this.contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          (<any> innerSubscription).context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window);\n\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n","import * as ActionCableNs from 'actioncable';\nimport { Observable, Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nconst ActionCable = ActionCableNs;\n\nexport class Cable {\n  baseCable: any;\n  private disconnectedSource: Subject<any> = new Subject();\n\n  constructor(public url: string, public params?: any) {\n    this.baseCable = ActionCable.createConsumer(this.buildUrl(url, params));\n\n    // If a function is passed as params, re-evaluate it before attempting to reconnect\n    if (params instanceof Function) {\n      this.disconnected().subscribe(() => {\n        this.baseCable.url = ActionCable.createWebSocketURL(this.buildUrl(url, params));\n      });\n    }\n  }\n\n  /**\n   * Create a new subscription to a channel, optionally with topic parameters.\n   */\n  channel(name: string, params = {}): Channel {\n    const channel = new Channel(this, name, params);\n    channel.disconnected().subscribe(data => this.disconnectedSource.next(data));\n    return channel;\n  }\n\n  /**\n   * Emits when the WebSocket connection is closed.\n   */\n  disconnected(): Observable<any> {\n    return this.disconnectedSource.asObservable().pipe(debounceTime(100));\n  }\n\n  /**\n   * Close the connection.\n   */\n  disconnect(): void {\n    this.baseCable.disconnect();\n  }\n\n  protected buildUrl(url: string, params?: any): string {\n    if (params instanceof Function) {\n      params = params();\n    }\n\n    if (!params) {\n      return url;\n    }\n\n    const paramString = Object.keys(params)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)\n      .join('&');\n\n    return [url, paramString].join('?');\n  }\n}\n\nexport class Channel {\n  baseChannel: any;\n  messages: Observable<any>;\n  private initializedSource: Subject<any> = new Subject();\n  private connectedSource: Subject<any> = new Subject();\n  private disconnectedSource: Subject<any> = new Subject();\n  private rejectedSource: Subject<any> = new Subject();\n  private eventTypes = ['initialized', 'connected', 'disconnected', 'rejected'];\n\n  constructor(public cable: Cable, public name: string, public params = {}) {\n    const channelParams = Object.assign({}, params, { channel: name });\n    this.messages = new Observable((observer) => {\n      const mixin = {\n        received: (data: any) => observer.next(data),\n      };\n\n      this.eventTypes.forEach((type) => {\n        mixin[type] = (data: any) => this[`${type}Source`].next(data);\n      });\n\n      this.baseChannel = this.cable.baseCable.subscriptions.create(channelParams, mixin);\n      return () => this.unsubscribe();\n    });\n  }\n\n  /**\n   * Emits messages that have been broadcast to the channel.\n   * For easy clean-up, when this Observable is completed the ActionCable channel will also be closed.\n   */\n  received(): Observable<any> {\n    return this.messages;\n  }\n\n  /**\n   * Emits when the subscription is initialized.\n   */\n  initialized(): Observable<any> {\n    return this.initializedSource.asObservable();\n  }\n\n  /**\n   * Emits when the subscription is ready for use on the server.\n   */\n  connected(): Observable<any> {\n    return this.connectedSource.asObservable();\n  }\n\n  /**\n   * Emits when the WebSocket connection is closed.\n   */\n  disconnected(): Observable<any> {\n    return this.disconnectedSource.asObservable();\n  }\n\n  /**\n   * Emits when the subscription is rejected by the server.\n   */\n  rejected(): Observable<any> {\n    return this.rejectedSource.asObservable();\n  }\n\n  /**\n   * Broadcast message to other clients subscribed to this channel.\n   */\n  send(data: any): void {\n    this.baseChannel.send(data);\n  }\n\n  /**\n   * Perform a channel action with the optional data passed as an attribute.\n   */\n  perform(action: string, data?: any): void {\n    this.baseChannel.perform(action, data);\n  }\n\n  /**\n   * Unsubscribe from the channel.\n   */\n  unsubscribe(): void {\n    this.baseChannel.unsubscribe();\n    this.eventTypes.forEach(type => this[`${type}Source`].complete());\n  }\n}\n","import { Injectable } from '@angular/core'\nimport { Cable } from './cable';\n\n@Injectable()\nexport class ActionCableService {\n  private cables: {[s: string]: Cable} = {};\n\n  /**\n   * Open a new ActionCable connection to the url. Any number of connections can be created.\n   */\n  cable(url: string, params?: any): Cable {\n    if (!this.cables.hasOwnProperty(url)) {\n      this.cables[url] = new Cable(url, params);\n    }\n\n    return this.cables[url];\n  }\n\n  /**\n   * Close an open connection for the url.\n   */\n  disconnect(url: string): void {\n    if (this.cables.hasOwnProperty(url)) {\n      this.cables[url].disconnect();\n      delete this.cables[url];\n    }\n  }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","isFunction","x","_enable_super_gross_mode_that_will_cause_bad_things","config","Promise","undefined","useDeprecatedSynchronousErrorHandling","value","Error","stack","hostReportError","err","setTimeout","empty","closed","next","error","complete","isObject","tryCatchTarget","tryCatcher","apply","arguments","e","errorObject","tryCatch","fn","UnsubscriptionErrorImpl","errors","call","message","length","map","i","toString","join","name","Subscription","unsubscribe","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","index","len","remove","UnsubscriptionError","flattenUnsubscriptionErrors","isArray","sub","concat","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","reduce","errs","rxSubscriber","Symbol","for","Subscriber","_super","destinationOrNext","_this","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","_parentSubscription","destination","emptyObserver","isTrustedSubscriber","obj","rxSubscriberSymbol","trustedSubscriber","_addParentTeardownLogic","SafeSubscriber","tslib_1.__extends","subscriber","_next","_error","_unsubscribeParentSubscription","_complete","parentTeardownLogic","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","Observable","subscribe","_isScalar","_subscribe","lift","operator","observable","source","sink","toSubscriber","nextOrObserver","_trySubscribe","forEach","promiseCtor","getPromiseCtor","resolve","reject","Symbol_observable","pipe","operations","_i","pipeFromArray","fns","piped","input","prev","noop","toPromise","ObjectUnsubscribedErrorImpl","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","AnonymousSubject","ObjectUnsubscribedError","copy","slice","thrownError","asObservable","AsyncAction","scheduler","work","schedule","state","delay","id","recycleAsyncId","pending","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","actions","Action","Scheduler","SchedulerAction","now","AsyncScheduler","delegate","active","scheduled","action","shift","async","DebounceTimeOperator","dueTime","DebounceTimeSubscriber","lastValue","hasValue","clearDebounce","debouncedSubscription","dispatchNext","debouncedNext","ActionCable","ActionCableNs","Cable","url","params","disconnectedSource","baseCable","createConsumer","buildUrl","Function","disconnected","createWebSocketURL","channel","Channel","data","debounceTime","disconnect","keys","key","encodeURIComponent","cable","initializedSource","connectedSource","rejectedSource","eventTypes","channelParams","assign","messages","observer","mixin","received","type","baseChannel","initialized","connected","rejected","send","perform","ActionCableService","cables","decorators","Injectable","ctorParameters"],"mappings":"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"}
